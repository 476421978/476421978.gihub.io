## 图片水印

:::demo

```vue
<template>
  <div class="content">
    <span
      >水印类型：<span>{{ waterType }}</span></span
    >
    <br />
    <canvas id="canvas" width="360" height="360"></canvas>

    <br />
    <div>
      <el-button type="primary" @click="onChangeWaterType">切换类型</el-button>
      <el-button type="primary" @click="onExportImg">导出</el-button>
    </div>

    <br />

    <img v-if="showImg" :src="imgPath" />
  </div>
</template>

<script setup>
import LOGO from '@/assets/home/logo.png'
import GLBG from '@/assets/home/gl_bj.png'

import { ref, onMounted } from 'vue'

const showImg = ref(false)
const imgPath = ref('')

const waterType = ref('rightBottom')

const onChangeWaterType = function () {
  if (waterType.value === 'full') {
    waterType.value = 'rightBottom'
  } else {
    waterType.value = 'full'
  }
  initCanvas()
  showImg.value = false
}

const onExportImg = function () {
  showImg.value = true
}

// 绘制
const initCanvas = function () {
  // const canvas = document.createElement('canvas')
  // canvas.width = 360
  // canvas.height = 360

  const canvas = document.getElementById('canvas')
  const ctx = canvas.getContext('2d')

  const imageC = new Image()
  imageC.src = GLBG

  imageC.onload = async function () {
    const canvasWidth = canvas.width
    const canvasHeight = canvas.height
    // 清空画布
    ctx.clearRect(0, 0, canvasWidth, canvasHeight)
    ctx.save()

    // 绘制底图
    ctx.drawImage(imageC, 0, 0, imageC.width, imageC.height, 0, 0, canvasWidth, canvasHeight)

    // 右下角
    waterType.value === 'rightBottom' && (await drawWaterMark({ ctx, img: LOGO, imgW: 50, imgH: 50, dW: canvasWidth - 50, dH: canvasHeight - 50 }))

    // 铺满
    waterType.value === 'full' && (await drawWaterMarks({ ctx, img: LOGO, canvas, canvasWidth, canvasHeight }))

    // 将画布转换为 Data URL
    const dataURL = canvas.toDataURL('image/png')
    // 使用 fetch() 将 Data URL 转换为 Blob
    fetch(dataURL)
      .then((response) => response.blob())
      .then((blob) => {
        // 使用 Blob 对象
        var image = new Image()
        image.src = URL.createObjectURL(blob)
        image.onload = () => {
          imgPath.value = image.src
          console.log('绘制完成')
        }
      })
  }
}

// 扩展- 将 canvas 转换为图像标签
const canvasChangeImg = function (canvas) {
  const image = canvas.toDataURL('image/png')
  const newImage = document.createElement('img')
  newImage.src = image
  return newImage
}

// 扩展-  图像标签转file格式
const imgChangeFile = function (canvas) {
  const imgbase64 = canvasChangeImg(canvas)
  // 删除 `data:image/png;base64,` 前缀
  const base64String = imgbase64.src.substring('data:image/png;base64,'.length)
  // 解码 `base64` 字符串
  const bytes = atob(base64String)
  // 将解码后的字符串保存到文件中
  const file = new File([bytes], 'image.png', { type: 'image/png' })

  return file
}

// 扩展- file转Blob
const fileToBlob = function (file) {
  return new Promise((resolve, reject) => {
    const fileReader = new FileReader()
    fileReader.onload = () => {
      const arrayBuffer = fileReader.result
      const blob = new Blob([arrayBuffer], { type: file.type })
      resolve(blob)
    }
    fileReader.onerror = () => {
      reject(new Error('Failed to convert file to blob'))
    }
    fileReader.readAsArrayBuffer(file)
  })
}

/**
 *
 * @param {绘制右下角水印}
 * ctx, img 必传
 */
const drawWaterMark = async function ({ ctx, img, opticy = 1, imgW = 50, imgH = 50, dW = 0, dH = 0 } = {}) {
  const waterImg = new Image()
  waterImg.src = img
  waterImg.width = imgW
  waterImg.width = imgH

  await new Promise((resolve, reject) => {
    waterImg.onload = function () {
      ctx.globalAlpha = opticy // 透明度设置
      ctx.drawImage(waterImg, dW, dH, imgW, imgH)
      resolve()
    }
  })
}

/**
 * @param {绘制铺满水印}
 * ctx, img, canvas 必传
 */
const drawWaterMarks = async function ({ ctx, img, canvas, canvasWidth = 0, canvasHeight = 0, imgW = 50, imgH = 50, rotateNum = 45, opticy = 1 } = {}) {
  const watermarkImage = new Image()
  watermarkImage.src = LOGO

  const watermarkHeight = imgH
  const watermarkWidth = imgW

  ctx.translate(-canvas.width / 2, 0) // 将画布平移到其中心点
  ctx.globalAlpha = opticy // 透明度
  ctx.rotate((-rotateNum * Math.PI) / 180) // 旋转画布

  await new Promise((resolve, reject) => {
    watermarkImage.onload = async function () {
      for (let i = 0; i < canvasWidth * 2; i += imgW + imgW * 2) {
        for (let j = 0; j < canvasHeight * 2; j += imgH + imgH * 2) {
          ctx.drawImage(watermarkImage, i, j, imgW, imgH)
        }
      }
      // 将画布平移回其原始位置
      ctx.restore()
      resolve()
    }
  })
}

onMounted(() => {
  initCanvas()
})
</script>

<style lang="scss" scoped></style>
```

:::
